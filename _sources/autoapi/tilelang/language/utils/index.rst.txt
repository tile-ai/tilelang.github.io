tilelang.language.utils
=======================

.. py:module:: tilelang.language.utils


Functions
---------

.. autoapisummary::

   tilelang.language.utils.region
   tilelang.language.utils.buffer_to_tile_region
   tilelang.language.utils.buffer_load_to_tile_region
   tilelang.language.utils.buffer_region_to_tile_region
   tilelang.language.utils.index_to_coordinates
   tilelang.language.utils.linear_index


Module Contents
---------------

.. py:function:: region(buffer, access_type, *args)

   Create a tile memory-region descriptor for a BufferLoad.

   Maps access_type ('r', 'w', 'rw') to the numeric codes expected by the `tl.region` intrinsic
   (1, 2, 3 respectively) and returns a tir.Call representing the region with the provided extents.

   :param buffer: The BufferLoad that identifies the underlying buffer and indices.
   :type buffer: tir.BufferLoad
   :param access_type: One of 'r', 'w', or 'rw' indicating read, write, or read-write access.
   :type access_type: str
   :param \*args: Extent expressions for each region dimension.
   :type \*args: tir.PrimExpr

   :returns: A call to the `tl.region` intrinsic describing the memory region.
   :rtype: tir.Call

   :raises KeyError: If access_type is not one of 'r', 'w', or 'rw'.


.. py:function:: buffer_to_tile_region(buffer, access_type)

   Convert a TVM buffer to a tile region descriptor.

   :param buffer: The buffer to convert
   :type buffer: tir.Buffer
   :param access_type: Type of access - 'r' for read, 'w' for write, 'rw' for read-write
   :type access_type: str

   :returns: A region descriptor covering the entire buffer
   :rtype: tir.Call


.. py:function:: buffer_load_to_tile_region(load, access_type, extents)

   Convert a buffer load operation to a tile region descriptor.

   :param load: The buffer load operation
   :type load: tir.BufferLoad
   :param access_type: Type of access - 'r' for read, 'w' for write, 'rw' for read-write
   :type access_type: str
   :param extents: List of expressions defining the region size
   :type extents: List[tir.PrimExpr]

   :returns: A region descriptor for the loaded area
   :rtype: tir.Call


.. py:function:: buffer_region_to_tile_region(buffer_region, access_type, extents)

   Convert a buffer region to a tile region descriptor.

   :param buffer_region: The buffer region to convert
   :type buffer_region: tir.BufferRegion
   :param access_type: Type of access - 'r' for read, 'w' for write, 'rw' for read-write
   :type access_type: str

   :returns: A region descriptor for the specified buffer region
   :rtype: tir.Call


.. py:function:: index_to_coordinates(index, shape)

   Convert a flat (linear) index into multi-dimensional coordinates for a given shape.

   Given a linear index and a shape (sequence of dimension extents), returns a list of coordinates (one per dimension) such that converting those coordinates back to a linear index using the usual row-major / C-order formula yields the original index. The computation iterates from the last dimension to the first using modulo and integer division, then reverses the collected coordinates.

   :param index: The flat index to convert.
   :type index: int or PrimExpr
   :param shape: The extents of each dimension (length >= 1).
   :type shape: Sequence[int]

   :returns: Coordinates for each dimension in the same order as `shape`.
   :rtype: List[PrimExpr]


.. py:function:: linear_index(*args)

   Compute a flat (linear) index from multi-dimensional coordinates and strides.

   The function accepts a sequence of PrimExpr arguments where the first portion are coordinates
   and the trailing portion are the corresponding strides. The number of strides must equal
   (number of coordinates - 1). The linear index is computed as:

       linear = coords[0]
       for each (coord, stride) in zip(coords[1:], strides):
           linear = linear * stride + coord

   .. rubric:: Examples

   - linear_index(i) -> i
   - linear_index(i, j) -> i * j_stride + j  (requires j_stride provided as stride when needed)
   - linear_index(i, j, stride_j) -> i * stride_j + j
   - linear_index(i, j, k, stride_j, stride_k) -> i*stride_j*stride_k + j*stride_k + k
   - linear_index(i, tx, v, threads, local_size) -> i*threads*local_size + tx*local_size + v

   :raises ValueError: If called with no arguments, or if the number of strides is not one less than
       the number of coordinates.

   :returns: The computed linear index expression.
   :rtype: PrimExpr


